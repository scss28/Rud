const std = @import("std");
const mem = std.mem;
const meta = std.meta;
const fmt = std.fmt;

const Ast = @import("Ast.zig");
const Env = @This();

gpa: mem.Allocator,
ast: *const Ast,
vars: std.StringArrayHashMapUnmanaged(Value),

err: Error = undefined,

const Error = struct {
    message: []const u8,
    node: Ast.Node.Index,
};

pub const EvalError = error{
    Eval,
} || mem.Allocator.Error;

pub const Float = f64;
pub const Value = union(Tag) {
    num: Float,
    nil,

    pub const Tag = enum {
        num,
        nil,
    };
};

pub fn eval(self: *Env, node: Ast.Node.Index) EvalError!Value {
    switch (self.ast.full(node)) {
        .identifier => |slice| {
            return self.vars.get(slice) orelse self.throw(
                "undefined variable",
                node,
            );
        },
        .number => |slice| {
            const num = fmt.parseFloat(f32, slice) catch unreachable;
            return .{ .num = num };
        },
        inline .add, .sub, .mul, .div => |binop, tag| {
            const lhs = try self.evalExpect(binop.lhs, .num);
            const rhs = try self.evalExpect(binop.rhs, .num);

            return switch (tag) {
                .add => lhs + rhs,
                .sub => lhs - rhs,
                .mul => lhs * rhs,
                .div => lhs / rhs,
                else => unreachable,
            };
        },
        .assign => |assign| {
            const key = try self.gpa.dupe(
                u8,
                assign.identifier,
            ); // AWESOME MEMORY LEAK
            const value = try self.eval(assign.rhs);
            try self.vars.put(self.gpa, key, value);

            return null;
        },
        .call => |call| {
            if (self.ast.nodeTag(call.callee) == .identifier) blk: {
                const identifier = self.ast.nodeTokenSlice(call.callee);
                const f = builtin_map.get(identifier) orelse break :blk;

                return f(self, call.args);
            }

            return self.throw("not a function", call.callee);
        },
    }
}

fn evalExpect(
    self: *Env,
    node: Ast.Node.Index,
    comptime tag: Value.Tag,
) EvalError!@TypeOf(@field(Value, @tagName(tag))) {
    const value = try self.eval(node);
    return switch (value) {
        tag => |v| v,
        else => |found_tag| self.throw(
            fmt.comptimePrint(
                "expected {s} found",
                .{ @tagName(tag), @tagName(foundTag) },
            ),
            node,
        ),
    };
}

fn throw(self: *Env, message: []const u8, node: Ast.Node.Index) error{Eval} {
    self.err = .{
        .message = message,
        .node = node,
    };
    return error.Eval;
}

fn assertExpectedLen(
    self: *Env,
    len: usize,
    comptime expected_len: usize,
    node: Ast.Node.Index,
) error{Eval}!void {
    if (len == expected_len) return;

    const message = fmt.comptimePrint("expected {d} arguments", .{expected_len});
    return self.throw(message, node);
}

const Builtin = fn (*Env, []const Ast.Node.Index) EvalError!Value;
const builtin_map: std.StaticStringMap(*const Builtin) = blk: {
    var kvs: []const struct { []const u8, Builtin } = &.{};
    for (@typeInfo(builtins).@"struct".decls) |decl| {
        kvs = kvs ++ .{.{ decl.name, @field(builtins, decl.name) }};
    }

    break :blk .initComptime(kvs);
};

const builtins = struct {
    const math = std.math;

    pub fn pow(
        env: *Env,
        args: []const Ast.Node.Index,
    ) EvalError!Value {
        try env.assertExpectedLen(args.len, 2, env.ast.root);

        const x = try env.evalExpect(args[0], .num);
        const n = try env.evalExpect(args[1], .num);

        return .{ .num = math.pow(Float, x, n) };
    }

    pub fn lerp(
        env: *Env,
        args: []const Ast.Node.Index,
    ) EvalError!Value {
        try env.assertExpectedLen(args.len, 3, env.ast.root);

        const a = try env.evalExpect(args[0], .num);
        const b = try env.evalExpect(args[1], .num);
        const t = try env.evalExpect(args[2], .num);

        return .{ .num = math.lerp(a, b, t) };
    }
};
